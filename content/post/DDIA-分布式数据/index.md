---
title: "DDIA 分布式数据"
description: 《设计数据密集型应用》第二章读书笔记
date: 2021-07-03T10:14:53+08:00
image: cover.jpg
math: 
license: 
hidden: false
draft: true
categories:
   - 数据库
tags:
   - 读书笔记
   - 分布式系统
   - DDIA
---
# 分布式数据

为什么需要分布式数据

- 可扩展性：当数据量，读写负载超出了单机的处理能力
- 容错/高可用：当部分机器出现故障时，可以切换到另外机器工作
- 延迟：在用户地域分布广泛时，选择访问其最近的数据中心



当单机处理不了当前的负载需求时，扩展方式可以是：

- 垂直扩展

  - 更换配置更高的机器（CPU, 内存，磁盘等）
  - 选择热插拔组件的机器，如内存条，使用网络通信的磁盘，甚至热插拔CPU

- 水平扩展

  - 由一系列机器（节点）组成一个集群作为整体对外工作，节点之间的协调由软件通过网络控制

  

垂直扩展的优势在于简单，没有软件协调导致的性能损耗，不存在分布式之间数据不一致，同步冲突等问题，缺点在于成本的上升速率比机器配置上升的速率更高，而且机器也不是可以无限制向上扩展。

相对而言，水平扩展的负载上限更高，廉价机器可以组成一个性价比高的集群，分散的数据除了可以容灾备份外，因地制宜选择就近数据中心可以有效减少请求延迟。但是分布式也有着部署复杂，更新冲突，同步延迟，数据不一致等问题，下面的章节将讲述分布式数据下面临的考验以及解决方案。



数据分布在多个节点有两种常见方式

- 复制（***Replication***）
  - 相同的数据副本存储在不同的节点，每个节点都拥有完备的数据
  - 复制最大的作用的容灾备份，当一部分节点宕机后，可以切换到其它节点工作
  - 复制同样有助于提高数据节点的性能，如在读写分离情况下，将提高系统的负荷能力
- 分区 （**Partitioning**）
  - 将一个完整的数据集拆分成多个子集，存储到不同的节点上
  - 数据系统/业务代码会根据请求分析其所需的数据在哪些节点上，从而正确的从不同的节点上获取组合数据



复制和分区两种形式不是对立，它们可以单独或者组合一起工作，如各个子数据集同样可以以复制的形式冗余在不同节点上。



## 复制



数据集总不是一成不变的，绝大部分都处于变更中，复制同步就成了首先要面对的问题。流行的三种变更复制算法如下：

- 单领导者
- 多领导者
- 无领导者



领导者（leader)是指在多副本中负责接受客户端的写入请求的副本，再写入数据到本地的同时，将变更的数据同步到其它追随者 (follower）副本上。

领导者可以接受客户端的读写数据操作，追随者只能接受读操作





### 单领导者

最常见的复制模式是一个领导者加一个或者多个追随者，这种模型也成为主从结构。许多数据库都内置了这种模型的支持，如MySQL，PostgreSQL，MongoDB等。



#### 同步复制与异步复制

当主库接收到写操作时，在写入到本地存储后，主库还会向从库转发数据更新操作。如果需要从库接收到数据更新操作并且从库成功更新数据后主库才向客户端相应成功写入，这种复制称为同步复制；如果只是转发了数据更新请求，但不需要等到从库确认写入主库就直接响应客户端，这种模式称为异步复制。

全部复制模式选择同步通常是不太实际的，因为单个节点失效的话就会导致整个系统不可用。所以大部分主从架构都是选择半同步——即同步复制与异步复制混用，主库只需要收到部分副本的的成功写入操作即可向客户端响应；或者选择全异步复制，这样会能更快响应客户端，但数据丢失的风险也会相应提高。



#### 故障转移（failover）

当主库宕机时，需要提升某个从库作为主库，客户端需要重新配置主库地址，从库需要切换领导者，这个过程称为故障转移。

故障转移可以人为解决，但很多情况下，我们希望得到自动故障转移的支持，即集群可以自动更新配置完成上诉操作。



自动故障转移通常包括下面步骤：

1. 确认主库失效
   - 如何判断主库失效是个难题，可能主库与从库只是短时间内网络阻塞了
   - 通常大多数系统只是简单的使用超时来判断主库的失效——节点之间会定时地传递消息（心跳），如果某个节点在一段时间内没有响应，则可以认为该节点失效
2. 选举出主库
   - 当失效的节点是主库时，这时需要剩余的副本阶段选举
3. 重新配置
          - 客户端更新写请求的endpoin指向新主库
          - 旧主库恢复时认可新主库，降级为从库

#### 复制日志实现

##### 基于语句的复制

记录写请求的语句（如MySQL中的Insert、Update、Delete等SQL)，将其转发给从库执行

存在的问题

- 存在非确定性值，如调用时间函数，
- 执行顺序需求，如语句依赖现有数据

MySQL5.1之前只支持基于语句的复制



##### WAL

预写式日志（Write-ahead logging， WAL)指在实际修改数据时先写入log文件，以支持事务中的回滚，MVCC等操作。日志文件包含了所有的数据库写入的仅追加字节数组，所以可以通过传输日志文件来构建一个相同的副本。

存在的问题

- 由于传输的是底层数据（字节数组），所以在存储方式发生了变化的不同数据库版本之间复制可能会出现不兼容问题

PostgreSQL、Oracle采用这种方式实现复制。



##### 基于行的复制

基于行的复制会以逻辑日志的形式传输以复制，逻辑日志通常以行为粒度，记录写请求前后受影响的行的前后状态，从库会将受影响的行变更为后者状态。这种方式也利于外部系统通过消费逻辑日志来捕捉数据库的变更。

MySQ支持基于行的复制，还支持基于语句混合基于行的复制。



##### 基于触发器的复制

当数据变更触发复制前时想要做一些额外的数据处理，处理借助外部的应用程序外，还可以借助触发器，存储过程来实现对应操作。如但数据变更时，将数据复制到另外一张表，外部程序读取该表以同步复制到其它库



#### 复制延迟

在分布式系统中，网络之间的通信是有延迟甚至中断的，复制延迟也因此产生，这就造成了客户端会读取从库上的旧数据，也就是常说的数据不一致问题。在有些业务系统中对数据的一致性要求比较高，比如金钱交易等，这种场景下可能分布式不是一个好的选择。但是如果业务场景可以接受短时间内的不一致的话，术语称之为最终一致性，那么我们的重心就放在了如何缩短主从复制之间的延迟。

下面介绍一下复制延迟的例子以及解决方案

##### 读写一致性 （read-your-writes consistency）

当用户提交了写操作，可能会因为从库同步延迟问题看不到自己的修改，这时可以通过一些措施来保证读写一致性

- 对于只能用户自身修改的内容，可以从主库读取
- 制定一个时间滞后差值，禁止从复制延迟超过这个差值的从库读取
- 记录客户端最后一次写入的时间戳（或者其他指示写入顺序的东西），只从同步超过了这个时间戳的从库读取数据（不过需要考虑同一用户多端设备的情况)

##### 单调读 （Monotonic reads）

即使在客户端纯读取的场景下，也可能因为每次读取的是不同从库导致数据不一致，这时需要保证单调读：

- 基于用户ID作hash来选择数据副本，确保用户的所有数据读取都来自同一个从库（除非从库发生了宕机等问题）

##### 一致前缀读 （consistent prefix reads）

由于不同的读取来自不同的从库，从库延迟不一致，导致数据的顺序混乱。这时需要保证一致前缀读——数据读取出现的顺序与其写入的顺序保持一致。可以采取

- 确保因果相关的写入都写入相同的分区
- 添加额外字段来标记顺序，读操作时通过顺序标识字段整合



















