<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.72.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>Go语言基础&nbsp;&ndash;&nbsp;lyeka</title><link rel="stylesheet" href="/css/core.min.898b08324caf28c40a0928ff1a3a1d0024b56b00fe08ccc2ed66248f1667b39240146cf362878e97e76ce14fd3419307.css" integrity="sha384-iYsIMkyvKMQKCSj/GjodACS1awD&#43;CMzC7WYkjxZns5JAFGzzYoeOl&#43;ds4U/TQZMH"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Go语言基础" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">lyeka</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/about">About</a></nav></div></span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">Go语言基础</h1><p class="article date">Monday, June 1, 2020</p></section><article class="article markdown-body"><h1 id="go语言基础">Go语言基础</h1>
<h2 id="数组字符串与切片">数组，字符串与切片</h2>
<p>Go语言中，数组，字符串，切片三种类型紧密相关，它们在底层原始数据有着相同的内存结构，在上层限制了语法而有着不同的表行。数组类型是字符串与切片类型的基础，关于数组的很多操作可以直接用于字符串与切片中。</p>
<h3 id="数组">数组</h3>
<p>数组是由<strong>固定长度</strong>的<strong>相同类型元素</strong>组成的序列。长度，元素类型都是数组的组成部分，不同长度，相同类型的数组是不同的类型，并不可以直接赋值、比较。</p>
<p>声明与初始化数组</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">a</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span>                    <span class="c1">// 定义长度为3的int型数组, 元素全部为0
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">b</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>       <span class="c1">// 定义长度为3的int型数组, 元素为 1, 2, 3
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">c</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>    <span class="c1">// 定义长度为3的int型数组, 元素为 0, 2, 3
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">d</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span> <span class="c1">// 定义长度为6的int型数组, 元素为 1, 2, 0, 0, 5, 6
</span></code></pre></div><p>在Go中，数组是值语义，一个数组变量即表示整个数组（不像C中数组变量是隐式指向数组第一个元素的指针），在数组变量被赋值或者被传递的时候，会复制整个数组，可以通过传递指向数组指针来规避这个开销。</p>
<p>通过数组指针和数组来操作数组在语法上并没有差别</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span> <span class="c1">// a 是一个数组
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">b</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">a</span>                <span class="c1">// b 是指向数组的指针
</span><span class="c1"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>   <span class="c1">// 打印数组的前2个元素
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>   <span class="c1">// 通过数组指针访问数组元素的方式和数组类似
</span><span class="c1"></span>
<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">b</span> <span class="p">{</span>     <span class="c1">// 通过数组指针迭代数组的元素
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>在数组中，len(长度)与cap(容量)是一致的。</p>
<p>迭代数组的几种方式，其中使用<code>for range</code>方式可以规避数组越界问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;a[%d]: %d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
<span class="p">}</span> 
<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">b</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;b[%d]: %d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;c[%d]: %d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">c</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div><h3 id="字符串">字符串</h3>
<p>字符串底层数据其实就是字节数组，不过只只读的，也就是是不可以改变底层的字节元素。字符串的长度虽然是固定的，但是字符串的长度并不是字符串类型的一部分。</p>
<p>字符串的底层结构在<code>reflect.StringHeader</code>中定义</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StringHeader</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Data</span> <span class="kt">uintptr</span>
    <span class="nx">Len</span>  <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div><p>Data字段即指向底层字节数组的指针，Len字段表示字符串的长度。</p>
<p>字符串支持切片操作，取出来的是字符串类型，通过位置索引取的话是byte/uint8类型</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="s">&#34;hello&#34;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>  <span class="c1">// string
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="c1">// uint8
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span> <span class="c1">// string
</span></code></pre></div><p>Go语言源文件采用utf8编码，其中出现的字符串字面量一般也是utf8编码（对于转义字符择没有这个限制）。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%#v\n&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;Hello, 世界&#34;</span><span class="p">))</span>

<span class="c1">// output
</span><span class="c1"></span><span class="p">[]</span><span class="kt">byte</span><span class="p">{</span><span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x65</span><span class="p">,</span> <span class="mh">0x6c</span><span class="p">,</span> <span class="mh">0x6c</span><span class="p">,</span> <span class="mh">0x6f</span><span class="p">,</span> <span class="mh">0x2c</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0xe4</span><span class="p">,</span> <span class="mh">0xb8</span><span class="p">,</span> <span class="mh">0x96</span><span class="p">,</span> <span class="mh">0xe7</span><span class="p">,</span> <span class="mh">0x95</span><span class="p">,</span> <span class="mh">0x8c</span><span class="p">}</span>
</code></pre></div><p>因为utf8是变长编码，所有底层字节数组的长度个字面量字符数量并不一定一致，上述例子中，中文在utf8中的是用3个字节表示的，所以字节数组的长度大于字面量字符数量。</p>
<p>迭代字符串不同的方法也会出现不同的结果</p>
<p>一、数组迭代</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="s">&#34;w噢&#34;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span><span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span>
<span class="p">}</span>

<span class="c1">// output
</span><span class="c1">// uint8
</span><span class="c1">// src:  119 after string:  w
</span><span class="c1">// src:  229 after string:  å
</span><span class="c1">// src:  153 after string:  
</span><span class="c1">// src:  162 after string:  ¢
</span></code></pre></div><p>这种方式是直接迭代了字符串底层的字节数组</p>
<p>二、<code>for range</code> 迭代</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
        <span class="nx">i</span><span class="o">+=</span><span class="mi">1</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;src:&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="s">&#34;after string: &#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// output
</span><span class="c1">// int32
</span><span class="c1">// src: 119 after string:  w
</span><span class="c1">// src: 22114 after string:  噢
</span></code></pre></div><p>使用<code>for range</code>迭代的话会遍历utf8解码后的unicode码点值</p>
<p>如何得到字符串中的字符数量</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="s">&#34;w噢&#34;</span><span class="p">))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">utf8</span><span class="p">.</span><span class="nf">RuneCountInString</span><span class="p">(</span><span class="s">&#34;w噢&#34;</span><span class="p">))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">([]</span><span class="nb">rune</span><span class="p">(</span><span class="s">&#34;w噢&#34;</span><span class="p">)))</span>

<span class="c1">// output
</span><span class="c1">// 4
</span><span class="c1">// 2
</span><span class="c1">// 2
</span></code></pre></div><h3 id="切片">切片</h3>
<p>切片即动态数组，长度不是固定的，故长度并不是切片的类型组成部分</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SliceHeader</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Data</span> <span class="kt">uintptr</span>
    <span class="nx">Len</span>  <span class="kt">int</span>
    <span class="nx">Cap</span>  <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div><p><strong>空切片和nil切片</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">s1</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="kd">var</span> <span class="nx">s2</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;s1:&#34;</span><span class="p">,</span> <span class="nx">s1</span><span class="o">==</span><span class="kc">nil</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s1</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s1</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;s2:&#34;</span><span class="p">,</span> <span class="nx">s2</span><span class="o">==</span><span class="kc">nil</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s2</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s2</span><span class="p">))</span>
<span class="p">}</span>
<span class="c1">// output
</span><span class="c1"></span><span class="nx">s1</span><span class="p">:</span> <span class="kc">true</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="nx">s2</span><span class="p">:</span> <span class="kc">false</span> <span class="mi">0</span> <span class="mi">0</span>
</code></pre></div><p>上述例子中，s1为nil切片，s2为空切片，虽然他们都长度和容量都是0，但nil切片底层的数据指针为nil。</p>
<p><strong>遍历</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"> <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;a[%d]: %d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">b</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;b[%d]: %d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;c[%d]: %d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">c</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="p">}</span>
</code></pre></div><p><strong>添加元素</strong></p>
<p>在容量不足的情况下，append操作会导致重新分配内存</p>
<p>尾部追加元素</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span>
<span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>               <span class="c1">// 追加1个元素
</span><span class="c1"></span><span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>         <span class="c1">// 追加多个元素, 手写解包方式
</span><span class="c1"></span><span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span><span class="o">...</span><span class="p">)</span> <span class="c1">// 追加一个切片, 切片需要解包
</span></code></pre></div><p>开头添加元素</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>
<span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="nx">a</span><span class="o">...</span><span class="p">)</span>        <span class="c1">// 在开头添加1个元素
</span><span class="c1"></span><span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="nx">a</span><span class="o">...</span><span class="p">)</span> <span class="c1">// 在开头添加1个切片
</span></code></pre></div><p>中间添加元素</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span>
<span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">[:</span><span class="nx">i</span><span class="p">],</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="nx">x</span><span class="p">},</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>     <span class="c1">// 在第i个位置插入x
</span><span class="c1"></span><span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">[:</span><span class="nx">i</span><span class="p">],</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span><span class="o">...</span><span class="p">)</span> <span class="c1">// 在第i个位置插入切片
</span><span class="c1"></span>

<span class="c1">// 避免创建中间临时切片
</span><span class="c1">// 插入单个元素
</span><span class="c1"></span><span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>     <span class="c1">// 切片扩展1个空间
</span><span class="c1"></span><span class="nb">copy</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">:])</span> <span class="c1">// a[i:]向后移动1个位置
</span><span class="c1"></span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">x</span>             <span class="c1">// 设置新添加的元素
</span><span class="c1"></span>
<span class="c1">// 插入多个元素
</span><span class="c1"></span><span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">x</span><span class="o">...</span><span class="p">)</span>       <span class="c1">// 为x切片扩展足够的空间
</span><span class="c1"></span><span class="nb">copy</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">):],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">:])</span> <span class="c1">// a[i:]向后移动len(x)个位置
</span><span class="c1"></span><span class="nb">copy</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">:],</span> <span class="nx">x</span><span class="p">)</span>            <span class="c1">// 复制新添加的切片
</span></code></pre></div><p><strong>删除元素</strong></p>
<p>删除尾部元素</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">a</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="nx">a</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="c1">// 删除尾部1个元素
</span><span class="c1"></span><span class="nx">a</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="o">-</span><span class="nx">N</span><span class="p">]</span>   <span class="c1">// 删除尾部N个元素
</span></code></pre></div><p>删除头部元素</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">a</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="nx">a</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="c1">// 删除开头1个元素
</span><span class="c1"></span><span class="nx">a</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">N</span><span class="p">:]</span> <span class="c1">// 删除开头N个元素
</span><span class="c1"></span>
<span class="nx">a</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">[:</span><span class="mi">0</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span> <span class="c1">// 删除开头1个元素
</span><span class="c1"></span><span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">[:</span><span class="mi">0</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">N</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span> <span class="c1">// 删除开头N个元素
</span><span class="c1"></span>
<span class="nx">a</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="nx">a</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[:</span><span class="nb">copy</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span> <span class="c1">// 删除开头1个元素
</span><span class="c1"></span><span class="nx">a</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[:</span><span class="nb">copy</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">a</span><span class="p">[</span><span class="nx">N</span><span class="p">:])]</span> <span class="c1">// 删除开头N个元素
</span></code></pre></div><p>删除中间元素</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">a</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">...</span><span class="p">}</span>

<span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">[:</span><span class="nx">i</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span> <span class="c1">// 删除中间1个元素
</span><span class="c1"></span><span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">[:</span><span class="nx">i</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="nx">N</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span> <span class="c1">// 删除中间N个元素
</span><span class="c1"></span>
<span class="nx">a</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[:</span><span class="nx">i</span><span class="o">+</span><span class="nb">copy</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">:],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:])]</span>  <span class="c1">// 删除中间1个元素
</span><span class="c1"></span><span class="nx">a</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[:</span><span class="nx">i</span><span class="o">+</span><span class="nb">copy</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">:],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="nx">N</span><span class="p">:])]</span>  <span class="c1">// 删除中间N个元素
</span></code></pre></div><p><strong>切片内存技巧</strong></p>
<p>巧用空切片</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 删除字节数组中的空格
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TrimSpace</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
    <span class="nx">b</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">x</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span> <span class="p">{</span>
            <span class="nx">b</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</code></pre></div><h2 id="函数-方法和接口">函数， 方法和接口</h2>
<p><img  src="https://chai2010.cn/advanced-go-programming-book/images/ch1-11-init.ditaa.png"
        alt/></p>
<p>上图为Go包初始化流程。一个包内可以有多个<code>init</code>函数， <code>init</code>函数在同一份文件的话，按顺序执行，不同文件相同包内的<code>init</code>函数执行顺序未定义（可能按文件名顺序）。</p>
<h3 id="函数">函数</h3>
<p>函数包括具名函数和匿名函数，支持多个参数和多个返回值。参数还支持可变数量的参数（可以用来当成可选函数？）， 其必选在参数列表最后出现，实际上可变数量函数为切片。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 多个参数和多个返回值
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Swap</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">a</span>
<span class="p">}</span>

<span class="c1">// 可变数量的参数
</span><span class="c1">// more 对应 []int 切片类型
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Sum</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">more</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">more</span> <span class="p">{</span>
        <span class="nx">a</span> <span class="o">+=</span> <span class="nx">v</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>
</code></pre></div><p>当可变参数是一个空接口类型时，调用者是否解包可变参数会导致不同的结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="p">[]</span><span class="kd">interface</span><span class="p">{}{</span><span class="mi">123</span><span class="p">,</span> <span class="s">&#34;abc&#34;</span><span class="p">}</span>

    <span class="nf">Print</span><span class="p">(</span><span class="nx">a</span><span class="o">...</span><span class="p">)</span> <span class="c1">// 123 abc
</span><span class="c1"></span>    <span class="nf">Print</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>    <span class="c1">// [123 abc]
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">Print</span><span class="p">(</span><span class="nx">a</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>需要注意的话，虽然可变数量参数为<code>...interface{}</code></p>
<p>但是直接将具体类型切片解包赋值给<code>...interface{}</code>是会保错的</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">123</span><span class="p">,</span> <span class="mi">246</span><span class="p">}</span>

	<span class="nf">Print</span><span class="p">(</span><span class="nx">a</span><span class="o">...</span><span class="p">)</span> <span class="c1">// 报错 cannot use a (type []int) as type []interface {} in argument to Print
</span><span class="c1"></span>	<span class="nf">Print</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>    <span class="c1">// 正常
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">Print</span><span class="p">(</span><span class="nx">a</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>因为<code>...interface{}</code>本质是<code>[]interface{}</code>, 解包赋值等同于将<code>[]int</code>转换为<code>[]interface{}</code>，这是不被允许的（详见https://github.com/golang/go/wiki/InterfaceSlice），而第二种不解包直接赋值等同于<code>[]interface{}[0] = a</code>，是可以正常通过的。</p>
<p>返回值可以被命名，如果返回值命名了，可以通过名字来修改返回值，也可以通过<code>defer</code>语句在<code>return</code>语句之后修改返回值：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Inc</span><span class="p">()</span> <span class="p">(</span><span class="nx">v</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">(){</span> <span class="nx">v</span><span class="o">++</span> <span class="p">}</span> <span class="p">()</span>
    <span class="k">return</span> <span class="mi">42</span> 
<span class="p">}</span>
</code></pre></div><p><code>return 42</code>等同于 <code>v = 42; return v</code></p>
<p>不过这个函数最终返回的是43， 因为使用<code>defer</code>延迟了一个匿名函数，这个函数捕获了外部函数v ，形成了闭包函数，闭包对外部变量的访问是引用方式，故可以改变v的值。</p>
<p>注意，延迟函数是会在<code>return</code>之前（不包含return后面的语句）执行的。上述例子实际上的顺序为</p>
<ol>
<li>v = 42</li>
<li>执行 defer 函数</li>
<li>return</li>
</ol>
<p>因为闭包是以引用来访问变量的话，故可能会导致一些隐含问题</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">defer</span> <span class="kd">func</span><span class="p">(){</span> <span class="nb">println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">}</span> <span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// Output:
</span><span class="c1">// 3
</span><span class="c1">// 3
</span><span class="c1">// 3
</span></code></pre></div><p>上面每个defer 函数以引用了i变量，在return之前执行，这时候循环已经完毕，i最终为3，所以三个输出都为3</p>
<p>解决办法</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">i</span> <span class="o">:=</span> <span class="nx">i</span> <span class="c1">// 定义一个循环体内局部变量i
</span><span class="c1"></span>        <span class="k">defer</span> <span class="kd">func</span><span class="p">(){</span> <span class="nb">println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">}</span> <span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="c1">// 通过函数传入i
</span><span class="c1"></span>        <span class="c1">// defer 语句会马上对调用参数求值
</span><span class="c1"></span>        <span class="k">defer</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">){</span> <span class="nb">println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">}</span> <span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>函数是是以传值的方式来访问传参数的，但如果参数本身为指针或者引用类型（如切片等），还是可以通过指针改变原参数的值的。</p>
<p>思考： 为什么append必须返回一个切片而不是直接改变切片呢？因为函数是传值的，虽然通过数据指针改变了底层的数据，但是len字段个cap字段没法改变，所以还是得通过返回新切片来更新切片。</p>
<p>Go中的函数递归调用在深度逻辑上没有限制（物理限制有），Go会动态的调整栈的大小。</p>
<p>在Go1.4后，Go的动态栈在内存上改为连续了，当所需内存不够时，runtime会自动将数据搬移到新的内存空间，栈变量的指针也会被自动更新，所以要记住Go的指针不是固定不变的，虽然对外使用无影响，但用一个数值变量保存指针的方式来访问指针指向会不靠谱。</p>
<p>Go中模糊了栈和堆的概念，使用者无须知道局部变量是保存在栈还是堆中，只需要知道他们可以正常工作即可，示例略。</p>
<h3 id="方法">方法</h3>
<p>方法就是关联到类型的函数。</p>
<p><strong>面对对象</strong></p>
<p>首先需要了解一下面对对象三大特征</p>
<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<p>关于多态可以阅读https://zhuanlan.zhihu.com/p/37655397</p>
<p>Go是不是面对对象语言不重要，Go官方给出的答案是yes and no，只能说Go支持面对对象编程，因为它提供了面对对象的三大特征Go均可以实现</p>
<p>封装就不啰嗦了，好理解。</p>
<p>关于继承，Go中是通过组合来实现的，通过组合，可以继承成员的内部成员以及成员的方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Cache</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
    <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Cache</span><span class="p">)</span> <span class="nf">Lookup</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

    <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div><p><code>Cache</code>这个结构体内部嵌入了<code>sync.Mutex</code>,  也就继承了<code>sync.Mutex</code>的<code>Lock</code>以及<code>Unlock</code>方法，虽然可以直接通过<code>p.Lock()</code>/<code>p.Unlock()</code>调用，但是实际上<code>lock</code>/<code>Unlock</code>方法的接收者为<code>Cache</code>的<code>sync.Mutex</code>成员。这种展开是编译期间完成的，没有运行时代价。</p>
<p>Go语言中方法是编译时静态绑定的。如果需要多态特性，我们需要借助Go语言接口来实现。</p>
<h3 id="接口">接口</h3>
<p>Go在提供严格类型检查的同时，通过接口类型实现了对鸭子类型的支持。接口类型是对其它类型行为的抽象和概括，Go中的接口类型独特支出在于它是满足隐式实现的鸭子类型。</p>
<p>Go语言中，对于基础类型（非接口类型）不支持隐式的转换，我们无法将一个<code>int</code>类型的值直接赋值给<code>int64</code>类型的变量，也无法将<code>int</code>类型的值赋值给底层是<code>int</code>类型的新定义命名类型的变量。Go语言对基础类型的类型一致性要求可谓是非常的严格，但是Go语言对于接口类型的转换则非常的灵活。对象和接口之间的转换、接口和接口之间的转换都可能是隐式的转换。可以看下面的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
    <span class="nx">a</span> <span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="p">)(</span><span class="nx">f</span><span class="p">)</span> <span class="c1">// 隐式转换, *os.File 满足 io.ReadCloser 接口
</span><span class="c1"></span>    <span class="nx">b</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span>     <span class="p">=</span> <span class="nx">a</span>             <span class="c1">// 隐式转换, io.ReadCloser 满足 io.Reader 接口
</span><span class="c1"></span>    <span class="nx">c</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Closer</span>     <span class="p">=</span> <span class="nx">a</span>             <span class="c1">// 隐式转换, io.ReadCloser 满足 io.Closer 接口
</span><span class="c1"></span>    <span class="nx">d</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span>     <span class="p">=</span> <span class="nx">c</span><span class="p">.(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="c1">// 显式转换, io.Closer 不满足 io.Reader 接口
</span><span class="c1"></span><span class="p">)</span>
</code></pre></div><p>[todo]</p>
<h2 id="面向并发的内存模型">面向并发的内存模型</h2>
<h3 id="goroutine-与系统线程">Goroutine 与系统线程</h3>
<p>系统线程一般会有一个固定大小的栈（一般默认 2 MB）， 用来保存函数递归调用时的参数和局部变量。</p>
<p>固定大小的栈存在两个问题：</p>
<ul>
<li>对于栈空间需求小的线程来说浪费资源</li>
<li>对于栈空间需求大的线程面临栈移溢出的风险</li>
</ul>
<p>Goroutine 是 Go 特有的并发体，其栈空间的大小是动态的，启动时候会很小（2/4 MB），当遇到深度递归导致栈空间不足时，会动态伸缩栈的大小（主流实现上限是 1 GB）。</p>
<p>Go 还实现了自己的调度器，其工作与内核的调度是类似的，不过只关注 Go 程序的 Goroutine。Go 调度器可以在 n 个操作系统线程上多工调度  m 个 Goroutine。 Goroutine 采用半抢占式协作调度，只有在当前 Goroutine 发生阻塞时才导致调度；同时发生在用户态，会根据具体函数只保存必要的寄存器，切换的代价比系统线程低得多。</p>
<p>运行时有一个<code>runtime.GOMAXPROCS</code>变量，用于控制当前运行正常非阻塞Goroutine的系统线程数目。</p>
<h3 id="原子操作">原子操作</h3>
<p>原子操作即“最小且不可并行化的”操作。在多线程并发情景下用于保证共享资源的完整性。</p>
<p>一般情况下，原子操作都是通过“互斥”访问来保证的，通常由特殊的 CPU 指令提供保护。</p>
<p>Go 标准库 <code>sync/atomic</code> 包对原子操作提供了丰富的支持</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;sync&#34;</span>
    <span class="s">&#34;sync/atomic&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">total</span> <span class="kt">uint64</span>

<span class="kd">func</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>

    <span class="kd">var</span> <span class="nx">i</span> <span class="kt">uint64</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">total</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">go</span> <span class="nf">worker</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">wg</span><span class="p">)</span>
    <span class="k">go</span> <span class="nf">worker</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">wg</span><span class="p">)</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p><code>sync/atomic</code> 包除了对除了基本的数值类型支持原子操作外，还通过 <code>atomic.Value</code> 对任意自定义复杂类型提供 <code>Load</code> 和 <code>Store</code> 两个原子方法。</p>
<p>标准库 <code>sync.Once</code> 实现</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Once</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">done</span> <span class="kt">uint32</span>
	<span class="nx">m</span>    <span class="nx">Mutex</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// Outlined slow-path to allow inlining of the fast-path.
</span><span class="c1"></span>        <span class="nx">o</span><span class="p">.</span><span class="nf">doSlow</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">doSlow</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">o</span><span class="p">.</span><span class="nx">done</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">defer</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nf">f</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>利用  <code>sync.Once</code> 实现单例模式</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
    <span class="nx">instance</span> <span class="o">*</span><span class="nx">singleton</span>
    <span class="nx">once</span>     <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">Instance</span><span class="p">()</span> <span class="o">*</span><span class="nx">singleton</span> <span class="p">{</span>
    <span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">instance</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">singleton</span><span class="p">{}</span>
    <span class="p">})</span>
    <span class="k">return</span> <span class="nx">instance</span>
<span class="p">}</span>
</code></pre></div><h3 id="顺序一致性内存模型">顺序一致性内存模型</h3>
<p>Go 语言中，在同一个 Goroutine 内， 顺序一致性内存模型是得到保证的。但是不同的 Goroutine 之间，并不满足顺序一致性内存模型，需要通过明确定义的同步事件来作为同步的参考。如果两个事件不可排序，那么就说这两个事件是并发的。为了最大并行化， Go 语言的编译器和处理器在不影响上述规定的前提下会对执行语句重新排序（CPU 也会对一些指令乱序执行）。</p>
<p>关于这个可以阅读 <a href="https://golang.org/ref/mem"target="_blank">The Go Memory Model</a></p>
<p>通过 channel 机制来明确排序以同步</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>

    <span class="k">go</span> <span class="kd">func</span><span class="p">(){</span>
        <span class="nb">println</span><span class="p">(</span><span class="s">&#34;你好, 世界&#34;</span><span class="p">)</span>
        <span class="nx">done</span> <span class="o">&lt;-</span> <span class="mi">1</span>
    <span class="p">}()</span>

    <span class="o">&lt;-</span><span class="nx">done</span>
<span class="p">}</span>
</code></pre></div><p>通过 <code>sync.Mutex</code> 互斥量来实现同步</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>

    <span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">(){</span>
        <span class="nb">println</span><span class="p">(</span><span class="s">&#34;你好, 世界&#34;</span><span class="p">)</span>
        <span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="p">}()</span>

    <span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h3 id="基于-channel-的通信">基于 Channel 的通信</h3>
<p>Channel 通信是在 Goroutine 之间进行同步的主要方法。</p>
<p>无缓存的 Channel 上的发送操作总在对应的接收操作完成之前发生。</p>
<p>对于有缓冲的 Channel， 该 Channel 的第 K 个接收完成发生在第 <code>K+C</code> 个发送操作完成之前，其中 C 是 Channel的缓冲大小。</p>
<p>使用 <code>Close</code> 关闭 channel ，接受者会收到该 channel 返回的零值。</p>
</article><section class="article labels"><a class="category" href=/categories/%E7%BC%96%E7%A8%8B/>编程</a><a class="tag" href=/tags/go/>go</a></section></div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/posts/mogodb%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/"><span class="li iconfont icon-article"></span>MongoDB中文文档</a></p></section>






<script src="https://utteranc.es/client.js"
        repo="lyeka/hugo-comment"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">©2020 lyeka. <span> &nbsp;|&nbsp; </span><span><a href='http://www.beian.miit.gov.cn/' target='_blank'>粤ICP备20037038号-1</a></span></p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section></body>

</html>